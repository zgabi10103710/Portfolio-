Object.defineProperty(exports, '__esModule', {
  value: true
});
var core = require('@urql/core');
var vue = require('vue');
var wonka = require('wonka');
function provideClient(opts) {
  var client;
  if (!vue.isRef(opts)) {
    client = vue.ref(opts instanceof core.Client ? opts : new core.Client(opts));
  } else {
    client = opts;
  }
  vue.provide('$urql', client);
  return client.value;
}
function install(app, opts) {
  var client;
  if (!vue.isRef(opts)) {
    client = vue.ref(opts instanceof core.Client ? opts : new core.Client(opts));
  } else {
    client = opts;
  }
  app.provide('$urql', client);
}
function useClient() {
  if (process.env.NODE_ENV !== 'production' && !vue.getCurrentInstance()) {
    throw new Error('use* functions may only be called during the `setup()` or other lifecycle hooks.');
  }
  var client = vue.inject('$urql');
  if (process.env.NODE_ENV !== 'production' && !client) {
    throw new Error('No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?');
  }
  return client;
}
function unwrapPossibleProxy(possibleProxy) {
  return possibleProxy && vue.isRef(possibleProxy) ? possibleProxy.value : possibleProxy;
}

/* eslint-disable react-hooks/rules-of-hooks */
var watchOptions$1 = {
  flush: 'pre'
};
function useQuery(args) {
  return callUseQuery(args);
}
function callUseQuery(_args, client = useClient(), stops = []) {
  var args = vue.reactive(_args);
  var data = vue.ref();
  var stale = vue.ref(false);
  var fetching = vue.ref(false);
  var error = vue.ref();
  var operation = vue.ref();
  var extensions = vue.ref();
  var isPaused = vue.isRef(_args.pause) ? _args.pause : vue.ref(!!_args.pause);
  var request = vue.ref(core.createRequest(args.query, unwrapPossibleProxy(args.variables)));
  var source = vue.ref();
  stops.push(vue.watchEffect(() => {
    var newRequest = core.createRequest(args.query, unwrapPossibleProxy(args.variables));
    if (request.value.key !== newRequest.key) {
      request.value = newRequest;
    }
  }, watchOptions$1));
  stops.push(vue.watchEffect(() => {
    source.value = !isPaused.value ? client.value.executeQuery(request.value, {
      requestPolicy: args.requestPolicy,
      ...args.context
    }) : undefined;
  }, watchOptions$1));
  var state = {
    data,
    stale,
    error,
    operation,
    extensions,
    fetching,
    isPaused,
    executeQuery(opts) {
      var s = source.value = client.value.executeQuery(request.value, {
        requestPolicy: args.requestPolicy,
        ...args.context,
        ...opts
      });
      return {
        ...response,
        then(onFulfilled, onRejected) {
          var sub;
          return new Promise(resolve => {
            var hasResult = false;
            sub = wonka.subscribe(() => {
              if (!state.fetching.value && !state.stale.value) {
                if (sub) sub.unsubscribe();
                hasResult = true;
                resolve(state);
              }
            })(s);
            if (hasResult) sub.unsubscribe();
          }).then(onFulfilled, onRejected);
        }
      };
    },
    pause() {
      isPaused.value = true;
    },
    resume() {
      isPaused.value = false;
    }
  };
  stops.push(vue.watchEffect(onInvalidate => {
    if (source.value) {
      fetching.value = true;
      stale.value = false;
      onInvalidate(wonka.subscribe(res => {
        data.value = res.data;
        stale.value = !!res.stale;
        fetching.value = false;
        error.value = res.error;
        operation.value = res.operation;
        extensions.value = res.extensions;
      })(wonka.onEnd(() => {
        fetching.value = false;
        stale.value = false;
      })(source.value)).unsubscribe);
    } else {
      fetching.value = false;
      stale.value = false;
    }
  }, {
    // NOTE: This part of the query pipeline is only initialised once and will need
    // to do so synchronously
    flush: 'sync'
  }));
  var response = {
    ...state,
    then(onFulfilled, onRejected) {
      var sub;
      var promise = new Promise(resolve => {
        if (!source.value) return resolve(state);
        var hasResult = false;
        sub = wonka.subscribe(() => {
          if (!state.fetching.value && !state.stale.value) {
            if (sub) sub.unsubscribe();
            hasResult = true;
            resolve(state);
          }
        })(source.value);
        if (hasResult) sub.unsubscribe();
      });
      return promise.then(onFulfilled, onRejected);
    }
  };
  return response;
}

/* eslint-disable react-hooks/rules-of-hooks */
function useMutation(query) {
  return callUseMutation(query);
}
function callUseMutation(query, client = useClient()) {
  var data = vue.ref();
  var stale = vue.ref(false);
  var fetching = vue.ref(false);
  var error = vue.ref();
  var operation = vue.ref();
  var extensions = vue.ref();
  return {
    data,
    stale,
    fetching,
    error,
    operation,
    extensions,
    executeMutation(variables, context) {
      fetching.value = true;
      return wonka.toPromise(wonka.take(1)(client.value.executeMutation(core.createRequest(query, unwrapPossibleProxy(variables)), context || {}))).then(res => {
        data.value = res.data;
        stale.value = !!res.stale;
        fetching.value = false;
        error.value = res.error;
        operation.value = res.operation;
        extensions.value = res.extensions;
        return res;
      });
    }
  };
}

/* eslint-disable react-hooks/rules-of-hooks */
var watchOptions = {
  flush: 'pre'
};
function useSubscription(args, handler) {
  return callUseSubscription(args, handler);
}
function callUseSubscription(_args, handler, client = useClient(), stops = []) {
  var args = vue.reactive(_args);
  var data = vue.ref();
  var stale = vue.ref(false);
  var fetching = vue.ref(false);
  var error = vue.ref();
  var operation = vue.ref();
  var extensions = vue.ref();
  var scanHandler = vue.ref(handler);
  var isPaused = vue.isRef(_args.pause) ? _args.pause : vue.ref(!!_args.pause);
  var request = vue.ref(core.createRequest(args.query, unwrapPossibleProxy(args.variables)));
  var source = vue.ref();
  stops.push(vue.watchEffect(() => {
    var newRequest = core.createRequest(args.query, unwrapPossibleProxy(args.variables));
    if (request.value.key !== newRequest.key) {
      request.value = newRequest;
    }
  }, watchOptions));
  stops.push(vue.watchEffect(() => {
    source.value = !isPaused.value ? client.value.executeSubscription(request.value, {
      ...args.context
    }) : undefined;
  }, watchOptions));
  stops.push(vue.watchEffect(onInvalidate => {
    if (source.value) {
      fetching.value = true;
      onInvalidate(wonka.subscribe(result => {
        fetching.value = true;
        data.value = result.data !== undefined ? typeof scanHandler.value === 'function' ? scanHandler.value(data.value, result.data) : result.data : result.data, error.value = result.error;
        extensions.value = result.extensions;
        stale.value = !!result.stale;
        operation.value = result.operation;
      })(wonka.onEnd(() => {
        fetching.value = false;
      })(source.value)).unsubscribe);
    } else {
      fetching.value = false;
    }
  }, watchOptions));
  var state = {
    data,
    stale,
    error,
    operation,
    extensions,
    fetching,
    isPaused,
    executeSubscription(opts) {
      source.value = client.value.executeSubscription(request.value, {
        ...args.context,
        ...opts
      });
      return state;
    },
    pause() {
      isPaused.value = true;
    },
    resume() {
      isPaused.value = false;
    }
  };
  return state;
}
function useClientHandle() {
  var client = useClient();
  var stops = [];
  vue.onBeforeUnmount(() => {
    var stop;
    while (stop = stops.shift()) {
      stop();
    }
  });
  var handle = {
    client: client.value,
    useQuery(args) {
      return callUseQuery(args, client, stops);
    },
    useSubscription(args, handler) {
      return callUseSubscription(args, handler, client, stops);
    },
    useMutation(query) {
      return callUseMutation(query, client);
    }
  };
  if (process.env.NODE_ENV !== 'production') {
    vue.onMounted(() => {
      Object.assign(handle, {
        useQuery(args) {
          if (process.env.NODE_ENV !== 'production' && !vue.getCurrentInstance()) {
            throw new Error('`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.');
          }
          return callUseQuery(args, client, stops);
        },
        useSubscription(args, handler) {
          if (process.env.NODE_ENV !== 'production' && !vue.getCurrentInstance()) {
            throw new Error('`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.');
          }
          return callUseSubscription(args, handler, client, stops);
        }
      });
    });
  }
  return handle;
}
exports["default"] = install;
exports.install = install;
exports.provideClient = provideClient;
exports.useClientHandle = useClientHandle;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useSubscription = useSubscription;
Object.keys(core).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return core[k];
    }
  });
});
//# sourceMappingURL=urql-vue.js.map
