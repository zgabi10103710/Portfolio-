import { Client as e, createRequest as u } from "@urql/core";

export * from "@urql/core";

import { isRef as r, ref as a, provide as l, getCurrentInstance as t, inject as n, reactive as s, watchEffect as i, onBeforeUnmount as o, onMounted as v } from "vue";

import { subscribe as c, onEnd as p, toPromise as f, take as y } from "wonka";

function provideClient(u) {
  var t;
  if (!r(u)) {
    t = a(u instanceof e ? u : new e(u));
  } else {
    t = u;
  }
  l("$urql", t);
  return t.value;
}

function install(u, l) {
  var t;
  if (!r(l)) {
    t = a(l instanceof e ? l : new e(l));
  } else {
    t = l;
  }
  u.provide("$urql", t);
}

function useClient() {
  if ("production" !== process.env.NODE_ENV && !t()) {
    throw new Error("use* functions may only be called during the `setup()` or other lifecycle hooks.");
  }
  var e = n("$urql");
  if ("production" !== process.env.NODE_ENV && !e) {
    throw new Error("No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?");
  }
  return e;
}

function unwrapPossibleProxy(e) {
  return e && r(e) ? e.value : e;
}

var b = {
  flush: "pre"
};

function useQuery(e) {
  return callUseQuery(e);
}

function callUseQuery(e, l = useClient(), t = []) {
  var n = s(e);
  var o = a();
  var v = a(!1);
  var f = a(!1);
  var y = a();
  var d = a();
  var h = a();
  var x = r(e.pause) ? e.pause : a(!!e.pause);
  var w = a(u(n.query, unwrapPossibleProxy(n.variables)));
  var P = a();
  t.push(i((() => {
    var e = u(n.query, unwrapPossibleProxy(n.variables));
    if (w.value.key !== e.key) {
      w.value = e;
    }
  }), b));
  t.push(i((() => {
    P.value = !x.value ? l.value.executeQuery(w.value, {
      requestPolicy: n.requestPolicy,
      ...n.context
    }) : void 0;
  }), b));
  var q = {
    data: o,
    stale: v,
    error: y,
    operation: d,
    extensions: h,
    fetching: f,
    isPaused: x,
    executeQuery(e) {
      var u = P.value = l.value.executeQuery(w.value, {
        requestPolicy: n.requestPolicy,
        ...n.context,
        ...e
      });
      return {
        ...E,
        then(e, r) {
          var a;
          return new Promise((e => {
            var r = !1;
            a = c((() => {
              if (!q.fetching.value && !q.stale.value) {
                if (a) {
                  a.unsubscribe();
                }
                r = !0;
                e(q);
              }
            }))(u);
            if (r) {
              a.unsubscribe();
            }
          })).then(e, r);
        }
      };
    },
    pause() {
      x.value = !0;
    },
    resume() {
      x.value = !1;
    }
  };
  t.push(i((e => {
    if (P.value) {
      f.value = !0;
      v.value = !1;
      e(c((e => {
        o.value = e.data;
        v.value = !!e.stale;
        f.value = !1;
        y.value = e.error;
        d.value = e.operation;
        h.value = e.extensions;
      }))(p((() => {
        f.value = !1;
        v.value = !1;
      }))(P.value)).unsubscribe);
    } else {
      f.value = !1;
      v.value = !1;
    }
  }), {
    flush: "sync"
  }));
  var E = {
    ...q,
    then(e, u) {
      var r;
      return new Promise((e => {
        if (!P.value) {
          return e(q);
        }
        var u = !1;
        r = c((() => {
          if (!q.fetching.value && !q.stale.value) {
            if (r) {
              r.unsubscribe();
            }
            u = !0;
            e(q);
          }
        }))(P.value);
        if (u) {
          r.unsubscribe();
        }
      })).then(e, u);
    }
  };
  return E;
}

function useMutation(e) {
  return callUseMutation(e);
}

function callUseMutation(e, r = useClient()) {
  var l = a();
  var t = a(!1);
  var n = a(!1);
  var s = a();
  var i = a();
  var o = a();
  return {
    data: l,
    stale: t,
    fetching: n,
    error: s,
    operation: i,
    extensions: o,
    executeMutation(a, v) {
      n.value = !0;
      return f(y(1)(r.value.executeMutation(u(e, unwrapPossibleProxy(a)), v || {}))).then((e => {
        l.value = e.data;
        t.value = !!e.stale;
        n.value = !1;
        s.value = e.error;
        i.value = e.operation;
        o.value = e.extensions;
        return e;
      }));
    }
  };
}

var d = {
  flush: "pre"
};

function useSubscription(e, u) {
  return callUseSubscription(e, u);
}

function callUseSubscription(e, l, t = useClient(), n = []) {
  var o = s(e);
  var v = a();
  var f = a(!1);
  var y = a(!1);
  var b = a();
  var h = a();
  var x = a();
  var w = a(l);
  var P = r(e.pause) ? e.pause : a(!!e.pause);
  var q = a(u(o.query, unwrapPossibleProxy(o.variables)));
  var E = a();
  n.push(i((() => {
    var e = u(o.query, unwrapPossibleProxy(o.variables));
    if (q.value.key !== e.key) {
      q.value = e;
    }
  }), d));
  n.push(i((() => {
    E.value = !P.value ? t.value.executeSubscription(q.value, {
      ...o.context
    }) : void 0;
  }), d));
  n.push(i((e => {
    if (E.value) {
      y.value = !0;
      e(c((e => {
        y.value = !0;
        v.value = void 0 !== e.data ? "function" == typeof w.value ? w.value(v.value, e.data) : e.data : e.data, 
        b.value = e.error;
        x.value = e.extensions;
        f.value = !!e.stale;
        h.value = e.operation;
      }))(p((() => {
        y.value = !1;
      }))(E.value)).unsubscribe);
    } else {
      y.value = !1;
    }
  }), d));
  var m = {
    data: v,
    stale: f,
    error: b,
    operation: h,
    extensions: x,
    fetching: y,
    isPaused: P,
    executeSubscription(e) {
      E.value = t.value.executeSubscription(q.value, {
        ...o.context,
        ...e
      });
      return m;
    },
    pause() {
      P.value = !0;
    },
    resume() {
      P.value = !1;
    }
  };
  return m;
}

function useClientHandle() {
  var e = useClient();
  var u = [];
  o((() => {
    var e;
    while (e = u.shift()) {
      e();
    }
  }));
  var r = {
    client: e.value,
    useQuery: r => callUseQuery(r, e, u),
    useSubscription: (r, a) => callUseSubscription(r, a, e, u),
    useMutation: u => callUseMutation(u, e)
  };
  if ("production" !== process.env.NODE_ENV) {
    v((() => {
      Object.assign(r, {
        useQuery(r) {
          if ("production" !== process.env.NODE_ENV && !t()) {
            throw new Error("`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseQuery(r, e, u);
        },
        useSubscription(r, a) {
          if ("production" !== process.env.NODE_ENV && !t()) {
            throw new Error("`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseSubscription(r, a, e, u);
        }
      });
    }));
  }
  return r;
}

export { install as default, install, provideClient, useClientHandle, useMutation, useQuery, useSubscription };
//# sourceMappingURL=urql-vue.mjs.map
